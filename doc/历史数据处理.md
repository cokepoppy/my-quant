# 历史数据处理

## 概述

量化交易系统中的历史数据处理是策略回测和分析的核心组件。本文档详细说明了系统中的历史数据处理流程，包括数据结构、处理逻辑和示例。

## 数据架构

### 数据库模型

```sql
model MarketData {
  id        String   @id @default(cuid())
  symbol    String
  timestamp DateTime
  open      Float
  high      Float
  low       Float
  close     Float
  volume    Float?
  interval  String   // '1m', '5m', '15m', '30m', '1h', '4h', '1d', '1w', '1M'
  source    String   @default("manual") // 'manual', 'api', 'feed'
  
  // TimescaleDB hypertable
  @@map("market_data")
}
```

### TimescaleDB 优化

- **Hypertable**: 时间序列数据自动分区
- **压缩**: 历史数据自动压缩存储
- **连续聚合**: 预计算常用指标
- **索引优化**: 时间戳和符号复合索引

## 数据处理流程

### 1. 数据导入

#### CSV 文件导入
```typescript
// 数据导入记录
model DataImport {
  id            Int      @id @default(autoincrement())
  fileName      String
  filePath      String
  fileType      String
  fileSize      Int
  dataType      String   // 'market', 'trading', 'strategy', 'user'
  timeFormat    String   @default("iso") // 'iso', 'unix', 'custom'
  dataSource    String?
  status        String   @default("pending") // 'pending', 'processing', 'success', 'failed'
  autoProcess   Boolean  @default(true)
  recordCount   Int?
  errorMessage  String?
  log           String?
  userId        String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}
```

#### API 数据获取
```typescript
// 简化的数据API路由
router.get('/simple', async (req, res) => {
  const { symbol, startDate, endDate, limit = 100 } = req.query;
  
  // 从数据库查询历史数据
  const marketData = await prisma.marketData.findMany({
    where: {
      symbol: symbol as string,
      timestamp: {
        gte: new Date(startDate as string),
        lte: new Date(endDate as string)
      }
    },
    orderBy: { timestamp: 'asc' },
    take: parseInt(limit as string)
  });
  
  res.json({ success: true, data: marketData });
});
```

### 2. 数据验证和清洗

#### 数据格式验证
```typescript
// 验证OHLCV数据格式
function validateMarketData(data: any[]): boolean {
  return data.every(item => 
    item.timestamp && 
    typeof item.open === 'number' &&
    typeof item.high === 'number' &&
    typeof item.low === 'number' &&
    typeof item.close === 'number' &&
    item.high >= item.low &&
    item.high >= item.open &&
    item.high >= item.close &&
    item.low <= item.open &&
    item.low <= item.close
  );
}
```

#### 数据清洗
```typescript
// 处理缺失数据和异常值
function cleanMarketData(data: any[]): any[] {
  return data.filter(item => {
    // 移除价格异常的数据点
    if (item.close <= 0 || item.high <= 0 || item.low <= 0) return false;
    
    // 移除价格波动过大的异常数据
    const priceChange = Math.abs(item.close - item.open) / item.open;
    if (priceChange > 0.5) return false; // 50%以上的波动认为是异常
    
    return true;
  });
}
```

### 3. 数据存储优化

#### 批量插入优化
```typescript
// 批量插入市场数据
async function bulkInsertMarketData(data: any[]) {
  const chunks = chunkArray(data, 1000); // 分批处理
  
  for (const chunk of chunks) {
    await prisma.marketData.createMany({
      data: chunk.map(item => ({
        symbol: item.symbol,
        timestamp: new Date(item.timestamp),
        open: item.open,
        high: item.high,
        low: item.low,
        close: item.close,
        volume: item.volume || 0,
        interval: item.interval || '1h',
        source: item.source || 'api'
      })),
      skipDuplicates: true
    });
  }
}
```

#### 时间序列索引
```sql
-- 创建复合索引优化查询性能
CREATE INDEX IF NOT EXISTS market_data_symbol_timestamp_idx 
ON market_data(symbol, timestamp DESC);

-- 创建时间范围索引
CREATE INDEX IF NOT EXISTS market_data_timestamp_idx 
ON market_data(timestamp DESC);
```

## 回测引擎数据使用

### 1. 数据查询

#### 基础查询
```typescript
// 查询指定时间范围的市场数据
async function getMarketDataForBacktest(
  symbol: string, 
  startDate: Date, 
  endDate: Date
) {
  return await prisma.marketData.findMany({
    where: {
      symbol,
      timestamp: {
        gte: startDate,
        lte: endDate
      }
    },
    orderBy: { timestamp: 'asc' }
  });
}
```

#### 多符号查询
```typescript
// 查询多个符号的市场数据
async function getMultiSymbolData(
  symbols: string[], 
  startDate: Date, 
  endDate: Date
) {
  return await prisma.marketData.findMany({
    where: {
      symbol: { in: symbols },
      timestamp: {
        gte: startDate,
        lte: endDate
      }
    },
    orderBy: [
      { symbol: 'asc' },
      { timestamp: 'asc' }
    ]
  });
}
```

### 2. 数据预处理

#### 技术指标计算
```typescript
// 计算移动平均线
function calculateMA(data: any[], period: number): number[] {
  const result = [];
  for (let i = period - 1; i < data.length; i++) {
    const sum = data.slice(i - period + 1, i + 1)
      .reduce((acc, item) => acc + item.close, 0);
    result.push(sum / period);
  }
  return result;
}

// 计算RSI
function calculateRSI(data: any[], period: number = 14): number[] {
  const result = [];
  const gains = [];
  const losses = [];
  
  for (let i = 1; i < data.length; i++) {
    const change = data[i].close - data[i-1].close;
    gains.push(change > 0 ? change : 0);
    losses.push(change < 0 ? Math.abs(change) : 0);
  }
  
  for (let i = period - 1; i < gains.length; i++) {
    const avgGain = gains.slice(i - period + 1, i + 1)
      .reduce((a, b) => a + b, 0) / period;
    const avgLoss = losses.slice(i - period + 1, i + 1)
      .reduce((a, b) => a + b, 0) / period;
    
    const rs = avgGain / avgLoss;
    const rsi = 100 - (100 / (1 + rs));
    result.push(rsi);
  }
  
  return result;
}
```

#### 数据标准化
```typescript
// 数据标准化处理
function normalizeData(data: any[]): any[] {
  const firstPrice = data[0].close;
  return data.map(item => ({
    ...item,
    normalizedClose: item.close / firstPrice,
    normalizedHigh: item.high / firstPrice,
    normalizedLow: item.low / firstPrice,
    normalizedOpen: item.open / firstPrice
  }));
}
```

### 3. 策略执行

#### SMA交叉策略
```typescript
// 简单移动平均线交叉策略
class SMACrossoverStrategy {
  async execute(data: any[], parameters: any) {
    const trades = [];
    const { shortPeriod = 10, longPeriod = 30, initialCapital = 10000 } = parameters;
    
    let capital = initialCapital;
    let position = 0;
    let entryPrice = 0;
    
    // 计算移动平均线
    const shortMA = this.calculateMA(data, shortPeriod);
    const longMA = this.calculateMA(data, longPeriod);
    
    // 执行策略
    for (let i = longPeriod - 1; i < data.length; i++) {
      const currentData = data[i];
      const currentShortMA = shortMA[i - shortPeriod + 1];
      const currentLongMA = longMA[i - longPeriod + 1];
      
      // 买入信号
      if (currentShortMA > currentLongMA && position <= 0) {
        position = capital * 0.1 / currentData.close;
        entryPrice = currentData.close;
        capital -= position * currentData.close;
        
        trades.push({
          timestamp: currentData.timestamp,
          type: 'buy',
          price: currentData.close,
          quantity: position,
          notes: 'SMA crossover buy signal'
        });
      }
      
      // 卖出信号
      else if (currentShortMA < currentLongMA && position > 0) {
        capital += position * currentData.close;
        
        trades.push({
          timestamp: currentData.timestamp,
          type: 'sell',
          price: currentData.close,
          quantity: position,
          notes: 'SMA crossover sell signal'
        });
        
        position = 0;
      }
    }
    
    return {
      finalCapital: capital + position * data[data.length - 1].close,
      trades,
      parameters
    };
  }
}
```

#### RSI均值回归策略
```typescript
// RSI均值回归策略
class RSIMeanReversionStrategy {
  async execute(data: any[], parameters: any) {
    const trades = [];
    const { rsiPeriod = 14, oversold = 30, overbought = 70, initialCapital = 10000 } = parameters;
    
    let capital = initialCapital;
    let position = 0;
    let entryPrice = 0;
    
    // 计算RSI
    const rsi = this.calculateRSI(data, rsiPeriod);
    
    // 执行策略
    for (let i = rsiPeriod; i < data.length; i++) {
      const currentData = data[i];
      const currentRSI = rsi[i - rsiPeriod];
      
      // 超卖买入信号
      if (currentRSI < oversold && position <= 0) {
        position = capital * 0.1 / currentData.close;
        entryPrice = currentData.close;
        capital -= position * currentData.close;
        
        trades.push({
          timestamp: currentData.timestamp,
          type: 'buy',
          price: currentData.close,
          quantity: position,
          notes: `RSI oversold buy signal (${currentRSI.toFixed(2)})`
        });
      }
      
      // 超买卖出信号
      else if (currentRSI > overbought && position > 0) {
        capital += position * currentData.close;
        
        trades.push({
          timestamp: currentData.timestamp,
          type: 'sell',
          price: currentData.close,
          quantity: position,
          notes: `RSI overbought sell signal (${currentRSI.toFixed(2)})`
        });
        
        position = 0;
      }
    }
    
    return {
      finalCapital: capital + position * data[data.length - 1].close,
      trades,
      parameters
    };
  }
}
```

## 数据样例

### 1. 原始市场数据格式

```json
[
  {
    "timestamp": "2024-01-01T00:00:00.000Z",
    "symbol": "BTCUSDT",
    "open": 42000.0,
    "high": 42500.0,
    "low": 41800.0,
    "close": 42300.0,
    "volume": 1500000.0,
    "interval": "1h"
  },
  {
    "timestamp": "2024-01-01T01:00:00.000Z",
    "symbol": "BTCUSDT",
    "open": 42300.0,
    "high": 42800.0,
    "low": 42100.0,
    "close": 42600.0,
    "volume": 1200000.0,
    "interval": "1h"
  }
]
```

### 2. 处理后的数据格式

```json
{
  "symbol": "BTCUSDT",
  "timeframe": "1h",
  "data": [
    {
      "timestamp": "2024-01-01T00:00:00.000Z",
      "open": 42000.0,
      "high": 42500.0,
      "low": 41800.0,
      "close": 42300.0,
      "volume": 1500000.0,
      "sma10": 42150.0,
      "sma30": 41980.0,
      "rsi14": 65.4,
      "normalizedClose": 1.0000
    },
    {
      "timestamp": "2024-01-01T01:00:00.000Z",
      "open": 42300.0,
      "high": 42800.0,
      "low": 42100.0,
      "close": 42600.0,
      "volume": 1200000.0,
      "sma10": 42200.0,
      "sma30": 42000.0,
      "rsi14": 68.2,
      "normalizedClose": 1.0071
    }
  ]
}
```

### 3. 回测结果格式

```json
{
  "backtestId": "clx1y2z3a4b5c6d7e8f9",
  "strategy": "SMA Crossover",
  "symbol": "BTCUSDT",
  "timeframe": "1h",
  "period": {
    "start": "2024-01-01T00:00:00.000Z",
    "end": "2024-01-31T23:00:00.000Z"
  },
  "performance": {
    "initialCapital": 10000.0,
    "finalCapital": 11250.0,
    "totalReturn": 0.125,
    "annualizedReturn": 0.15,
    "sharpeRatio": 1.8,
    "maxDrawdown": 0.08,
    "winRate": 0.65,
    "profitFactor": 1.8,
    "totalTrades": 25,
    "averageTrade": 50.0
  },
  "trades": [
    {
      "id": "trade1",
      "timestamp": "2024-01-05T10:00:00.000Z",
      "type": "buy",
      "side": "long",
      "symbol": "BTCUSDT",
      "quantity": 0.0238,
      "price": 42000.0,
      "commission": 1.0,
      "slippage": 0.5,
      "status": "completed"
    },
    {
      "id": "trade2",
      "timestamp": "2024-01-08T14:00:00.000Z",
      "type": "sell",
      "side": "long",
      "symbol": "BTCUSDT",
      "quantity": 0.0238,
      "price": 43000.0,
      "commission": 1.0,
      "slippage": 0.5,
      "pnl": 238.0,
      "profit": 235.5,
      "status": "completed"
    }
  ],
  "equityCurve": [
    {
      "timestamp": "2024-01-01T00:00:00.000Z",
      "value": 10000.0
    },
    {
      "timestamp": "2024-01-02T00:00:00.000Z",
      "value": 10050.0
    }
  ]
}
```

## 性能优化

### 1. 查询优化

```sql
-- 使用TimescaleDB的time_bucket函数进行时间聚合
SELECT 
  time_bucket('1 day', timestamp) AS bucket,
  symbol,
  first(open, timestamp) AS open,
  max(high) AS high,
  min(low) AS low,
  last(close, timestamp) AS close,
  sum(volume) AS volume
FROM market_data
WHERE symbol = 'BTCUSDT'
  AND timestamp >= '2024-01-01'
  AND timestamp <= '2024-01-31'
GROUP BY bucket, symbol
ORDER BY bucket;
```

### 2. 内存优化

```typescript
// 流式处理大量历史数据
async function processLargeDataset(
  symbol: string,
  startDate: Date,
  endDate: Date,
  chunkSize: number = 10000
) {
  let offset = 0;
  let hasMore = true;
  
  while (hasMore) {
    const chunk = await prisma.marketData.findMany({
      where: {
        symbol,
        timestamp: {
          gte: startDate,
          lte: endDate
        }
      },
      orderBy: { timestamp: 'asc' },
      skip: offset,
      take: chunkSize
    });
    
    if (chunk.length === 0) {
      hasMore = false;
      break;
    }
    
    // 处理数据块
    await processChunk(chunk);
    
    offset += chunkSize;
  }
}
```

### 3. 缓存策略

```typescript
// 实现数据缓存
class MarketDataCache {
  private cache = new Map();
  private ttl = 5 * 60 * 1000; // 5分钟缓存
  
  async get(symbol: string, timeframe: string): Promise<any[]> {
    const key = `${symbol}_${timeframe}`;
    const cached = this.cache.get(key);
    
    if (cached && Date.now() - cached.timestamp < this.ttl) {
      return cached.data;
    }
    
    // 从数据库获取数据
    const data = await this.fetchFromDB(symbol, timeframe);
    
    // 更新缓存
    this.cache.set(key, {
      data,
      timestamp: Date.now()
    });
    
    return data;
  }
}
```

## 监控和维护

### 1. 数据质量监控

```typescript
// 数据质量检查
async function checkDataQuality(symbol: string, days: number = 7) {
  const endDate = new Date();
  const startDate = new Date(endDate.getTime() - days * 24 * 60 * 60 * 1000);
  
  const data = await prisma.marketData.findMany({
    where: {
      symbol,
      timestamp: {
        gte: startDate,
        lte: endDate
      }
    }
  });
  
  const qualityReport = {
    totalRecords: data.length,
    expectedRecords: days * 24, // 假设1小时数据
    missingRecords: days * 24 - data.length,
    dataGaps: [],
    anomalies: [],
    averageVolume: data.reduce((sum, d) => sum + (d.volume || 0), 0) / data.length,
    priceVolatility: this.calculateVolatility(data)
  };
  
  return qualityReport;
}
```

### 2. 数据备份策略

```sql
-- 创建数据备份表
CREATE TABLE market_data_backup_2024 AS 
SELECT * FROM market_data 
WHERE timestamp >= '2024-01-01' 
  AND timestamp < '2025-01-01';

-- 压缩历史数据
ALTER TABLE market_data_backup_2024 
SET (timescaledb.compress, timescaledb.compress_segmentby = 'symbol');
```

## 总结

历史数据处理是量化交易系统的基础，包括：

1. **数据获取**: 支持CSV导入和API获取
2. **数据验证**: 确保数据质量和一致性
3. **数据存储**: 使用TimescaleDB优化时间序列数据
4. **数据预处理**: 计算技术指标和标准化
5. **策略执行**: 支持多种交易策略
6. **性能优化**: 查询优化和缓存策略
7. **数据监控**: 质量检查和备份策略

这个系统为量化策略的回测和分析提供了完整的数据处理解决方案。