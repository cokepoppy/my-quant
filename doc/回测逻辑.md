# 回测实现逻辑

## 概述

本系统拥有一个完整的回测框架，结合了现代的 Prisma/TimescaleDB 架构和传统的 MongoDB 实现。系统支持多种数据源、策略执行引擎和性能分析功能。

## 系统架构

### 数据层
- **TimescaleDB**: 时间序列数据存储，优化 OHLCV 数据查询
- **PostgreSQL**: 关系型数据存储（用户、策略、回测记录）
- **MongoDB**: 文档存储（高级分析报告、优化历史）

### 服务层
- **DataManager**: 统一数据管理，支持多种数据源适配器
- **BacktestEngine**: 回测执行引擎，支持策略运行和性能计算
- **StrategyExecutor**: 策略执行器，解析和执行策略代码
- **RiskManager**: 风险管理模块，处理仓位控制和止损

### API层
- **RESTful API**: 标准的 HTTP 接口
- **WebSocket**: 实时数据传输和进度更新
- **Socket.IO**: 事件驱动的通信机制

## 历史数据管理

### 数据源
1. **Yahoo Finance**
   - 股票数据：美股、A股
   - 加密货币数据：BTC、ETH等
   - 指数数据：上证指数、深证成指等

2. **数据格式**
   ```typescript
   interface MarketData {
     symbol: string;
     timestamp: Date;
     open: number;
     high: number;
     low: number;
     close: number;
     volume: number;
     interval: string; // 1m, 5m, 15m, 30m, 1h, 4h, 1d, 1w, 1M
   }
   ```

### 数据获取流程
1. **数据请求** → DataManager
2. **缓存检查** → Redis缓存
3. **数据源获取** → YahooFinanceAdapter
4. **数据验证** → 格式和完整性检查
5. **数据存储** → TimescaleDB
6. **索引更新** → 优化查询性能

### 数据存储结构
```sql
-- TimescaleDB 超表结构
CREATE TABLE market_data (
  time TIMESTAMP NOT NULL,
  symbol TEXT NOT NULL,
  open DOUBLE PRECISION,
  high DOUBLE PRECISION,
  low DOUBLE PRECISION,
  close DOUBLE PRECISION,
  volume BIGINT
);

-- 创建超表
SELECT create_hypertable('market_data', 'time');

-- 创建索引
CREATE INDEX ON market_data (symbol, time DESC);
```

## 回测执行引擎

### 核心组件

#### 1. BacktestEngine
```typescript
class BacktestEngine {
  async runBacktest(config: BacktestConfig): Promise<BacktestResult> {
    // 1. 数据准备
    const data = await this.prepareData(config);
    
    // 2. 策略初始化
    const strategy = await this.initializeStrategy(config.strategy);
    
    // 3. 回测执行
    const trades = await this.executeStrategy(data, strategy, config);
    
    // 4. 性能分析
    const metrics = await this.calculatePerformance(trades, data);
    
    // 5. 结果存储
    return await this.saveResults(config, trades, metrics);
  }
}
```

#### 2. StrategyExecutor
```typescript
class StrategyExecutor {
  async execute(strategy: Strategy, data: MarketData[], config: BacktestConfig): Promise<Trade[]> {
    const trades: Trade[] = [];
    let currentPosition = null;
    
    for (const candle of data) {
      // 执行策略逻辑
      const signals = await strategy.generateSignals(candle);
      
      // 处理信号
      for (const signal of signals) {
        const trade = await this.processSignal(signal, currentPosition, config);
        if (trade) {
          trades.push(trade);
          currentPosition = trade;
        }
      }
    }
    
    return trades;
  }
}
```

#### 3. RiskManager
```typescript
class RiskManager {
  validateSignal(signal: Signal, config: BacktestConfig): boolean {
    // 1. 最大仓位检查
    if (signal.positionSize > config.maxPositionSize) {
      return false;
    }
    
    // 2. 资金检查
    if (signal.requiredCapital > config.availableCapital) {
      return false;
    }
    
    // 3. 风险限额检查
    if (this.calculateRisk(signal) > config.maxRiskPerTrade) {
      return false;
    }
    
    return true;
  }
}
```

## 回测配置

### 基础配置
```typescript
interface BacktestConfig {
  // 策略配置
  strategyId: string;
  strategyParams: Record<string, any>;
  
  // 数据配置
  symbol: string;
  timeframe: string;
  startDate: Date;
  endDate: Date;
  
  // 资金管理
  initialCapital: number;
  maxPositionSize: number;
  leverage: number;
  
  // 风险管理
  stopLoss: number;
  takeProfit: number;
  maxRiskPerTrade: number;
  
  // 交易成本
  commission: number;
  slippage: number;
}
```

### 高级配置
```typescript
interface AdvancedBacktestConfig extends BacktestConfig {
  // 优化配置
  optimization: {
    enabled: boolean;
    parameters: ParameterRange[];
    algorithm: 'grid' | 'genetic' | 'bayesian';
    iterations: number;
  };
  
  // 分析配置
  analysis: {
    monteCarlo: boolean;
    scenarios: number;
    walkForward: boolean;
    windowSize: number;
    stepSize: number;
  };
}
```

## 性能指标计算

### 收益指标
- **总收益率**: (最终价值 - 初始资金) / 初始资金
- **年化收益率**: (1 + 总收益率)^(365/天数) - 1
- **超额收益率**: 策略收益率 - 基准收益率

### 风险指标
- **夏普比率**: (年化收益率 - 无风险利率) / 年化波动率
- **索提诺比率**: (年化收益率 - 无风险利率) / 下行波动率
- **最大回撤**: 最大资产价值下降幅度
- **贝塔系数**: 策略相对于基准的波动性

### 交易指标
- **胜率**: 盈利交易次数 / 总交易次数
- **盈亏比**: 平均盈利 / 平均亏损
- **交易次数**: 总交易次数
- **平均持仓时间**: 平均交易持仓时长

## 策略开发框架

### 策略接口
```typescript
interface Strategy {
  name: string;
  description: string;
  
  // 初始化
  initialize(params: Record<string, any>): Promise<void>;
  
  // 信号生成
  generateSignals(data: MarketData): Promise<Signal[]>;
  
  // 风险管理
  validateSignal(signal: Signal): boolean;
  
  // 清理资源
  cleanup(): Promise<void>;
}
```

### 信号类型
```typescript
interface Signal {
  type: 'buy' | 'sell' | 'hold';
  symbol: string;
  price: number;
  quantity: number;
  timestamp: Date;
  confidence: number;
  metadata: Record<string, any>;
}
```

### 示例策略
```typescript
class SMACrossoverStrategy implements Strategy {
  private shortPeriod: number;
  private longPeriod: number;
  
  async initialize(params: any) {
    this.shortPeriod = params.shortPeriod || 10;
    this.longPeriod = params.longPeriod || 30;
  }
  
  async generateSignals(data: MarketData[]): Promise<Signal[]> {
    const signals: Signal[] = [];
    
    // 计算移动平均线
    const shortMA = this.calculateSMA(data, this.shortPeriod);
    const longMA = this.calculateSMA(data, this.longPeriod);
    
    // 生成信号
    for (let i = 1; i < data.length; i++) {
      if (shortMA[i] > longMA[i] && shortMA[i-1] <= longMA[i-1]) {
        signals.push({
          type: 'buy',
          symbol: data[i].symbol,
          price: data[i].close,
          quantity: 100,
          timestamp: data[i].timestamp,
          confidence: 0.8,
          metadata: { strategy: 'SMA Crossover' }
        });
      }
    }
    
    return signals;
  }
}
```

## 回测结果存储

### 数据库结构
```sql
-- 回测主表
CREATE TABLE backtests (
  id UUID PRIMARY KEY,
  strategy_id UUID REFERENCES strategies(id),
  user_id UUID REFERENCES users(id),
  name VARCHAR(255),
  status VARCHAR(50),
  config JSONB,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- 交易记录表
CREATE TABLE trades (
  id UUID PRIMARY KEY,
  backtest_id UUID REFERENCES backtests(id),
  strategy_id UUID REFERENCES strategies(id),
  symbol VARCHAR(50),
  type VARCHAR(10),
  price DECIMAL(20,8),
  quantity DECIMAL(20,8),
  profit DECIMAL(20,8),
  timestamp TIMESTAMP,
  metadata JSONB
);

-- 性能指标表
CREATE TABLE performance_metrics (
  id UUID PRIMARY KEY,
  backtest_id UUID REFERENCES backtests(id),
  total_return DECIMAL(10,4),
  sharpe_ratio DECIMAL(10,4),
  max_drawdown DECIMAL(10,4),
  win_rate DECIMAL(10,4),
  profit_factor DECIMAL(10,4),
  total_trades INTEGER,
  created_at TIMESTAMP DEFAULT NOW()
);
```

## API接口设计

### 回测操作接口
```typescript
// 启动回测
POST /api/backtest/run
{
  "strategyId": "uuid",
  "config": BacktestConfig
}

// 获取回测状态
GET /api/backtest/:id/status

// 获取回测结果
GET /api/backtest/:id/results

// 取消回测
POST /api/backtest/:id/cancel

// 获取回测历史
GET /api/backtest/history
```

### 数据接口
```typescript
// 获取历史数据
GET /api/data/historical
{
  "symbol": "BTCUSDT",
  "timeframe": "1h",
  "startDate": "2023-01-01",
  "endDate": "2023-12-31"
}

// 获取可用数据源
GET /api/data/sources

// 获取支持的时间周期
GET /api/data/timeframes
```

## 前端实现

### 组件结构
```
BacktestWorkflow/
├── BacktestConfig.vue      # 回测配置
├── BacktestExecution.vue   # 回测执行
├── BacktestResults.vue     # 结果展示
└── BacktestAnalysis.vue    # 性能分析
```

### 状态管理
```typescript
// Pinia Store
export const useBacktestStore = defineStore('backtest', {
  state: () => ({
    currentBacktest: null,
    backtestHistory: [],
    isRunning: false,
    progress: 0
  }),
  
  actions: {
    async startBacktest(config) {
      // 启动回测
    },
    
    async getBacktestResults(id) {
      // 获取结果
    }
  }
});
```

## 部署和扩展

### 性能优化
1. **并行处理**: 多策略并行回测
2. **数据缓存**: Redis缓存历史数据
3. **增量计算**: 只计算新增数据
4. **分布式处理**: 支持多机部署

### 监控和日志
1. **性能监控**: 实时监控回测进度
2. **错误处理**: 完善的错误处理机制
3. **日志记录**: 详细的操作日志
4. **告警系统**: 异常情况告警

## 开发计划

### 第一阶段：核心功能
- [x] 基础数据库架构
- [x] 数据获取模块
- [x] 基础回测引擎
- [ ] 策略执行框架
- [ ] 性能指标计算

### 第二阶段：高级功能
- [ ] 参数优化
- [ ] 蒙特卡洛模拟
- [ ] 实时数据集成
- [ ] 高级风险管理

### 第三阶段：用户体验
- [ ] 可视化图表
- [ ] 报告生成
- [ ] 移动端支持
- [ ] API文档

## 技术栈总结

- **后端**: Node.js + Express + TypeScript + Prisma
- **数据库**: PostgreSQL + TimescaleDB + Redis
- **前端**: Vue3 + TypeScript + Element Plus + Chart.js
- **消息队列**: BullMQ (Redis)
- **实时通信**: Socket.IO
- **部署**: Docker + Docker Compose

这个回测系统提供了完整的量化交易回测解决方案，支持多种策略类型、丰富的性能分析功能和良好的扩展性。